## 漏洞描述

XStream in multiple applications, including JBoss A-MQ, JBoss Fuse, and JBoss BRMS, through version 1.4.9 is vulnerable due to improper input validation during unmarshalling when a certain denyTypes workaround is not employed [[7]](#引用) . This vulnerability allows an unauthenticated attacker to cause a denial of service (DoS) by exploiting the `xstream.fromXML("<void/>")` call to crash the remote application [[7]](#引用) [[1]](#引用) . The issue arises from mishandling the creation of an instance of the primitive type 'void', potentially leading to resource exhaustion and service unavailability [[7]](#引用) [[6]](#引用) .

## 详细描述

CVE-2017-7957 is a high-severity vulnerability affecting XStream versions up to and including 1.4.9 [[7]](#引用) , characterized by improper handling of XML input during deserialization [[7]](#引用) . The vulnerability allows an attacker to exploit the system by providing a malicious XML input that attempts to create an instance of the primitive type 'void' using the syntax <void/> [[1]](#引用) . When processed by the library without implementing the required denyTypes workaround, this can lead to a denial-of-service (DoS) condition, resulting in an unexpected application crash [[7]](#引用) [[3]](#引用) .

This vulnerability is classified under CWE-20 (Improper Input Validation) [[7]](#引用)  and has been assigned a CVSS v3.0 score of 7.5, indicating a significant impact on availability [[7]](#引用) . The flaw allows remote exploitation, requiring no authentication or user interaction, thereby amplifying its risk [[3]](#引用) . Specific implementations of XStream that do not utilize the recommended safeguards are particularly vulnerable to this type of attack [[7]](#引用) .

Mitigation strategies include immediate patching of affected versions or application of the denyTypes workaround to limit the capability of deserializing untrusted input [[7]](#引用) [[3]](#引用) . Further, while related XML External Entity (XXE) vulnerabilities may also exist [[2]](#引用) , this specific issue directly impacts resource management during the unmarshalling process [[7]](#引用) . Organizations are advised to prioritize remediation efforts to protect systems reliant on XStream [[7]](#引用) .

## 排查步骤(生成式)

1. Check for XStream usage: Verify if your application utilizes the XStream library for XML processing.
   
```bash
   # Check if XStream is in use by locating the library in the application dependencies
   grep -r "xstream" /path/to/your/application
```  
   This check confirms whether the application relies on the vulnerable library, establishing a necessary condition for potential exploitability.

2. Review affected versions: If XStream is in use, determine the version of XStream within your application. If the version is 1.4.9 or earlier, the application is vulnerable.
   
```bash
   # Check the version of the XStream library
   grep "xstream.version" /path/to/your/app/META-INF/MANIFEST.MF
```  
   This step ascertains if the application is running a vulnerable version of XStream, confirming its susceptibility to the CVE.

3. Verify configuration for denyTypes: Validate whether the `denyTypes` configuration is implemented correctly in the XStream setup. Without this, the application is at risk of exploitation.
   
```bash
   # Check Java configuration or source code for the denyTypes setting
   grep -r "denyTypes" /path/to/your/application
```  
   This check determines if the input validation measure is in place, which directly impacts the exploitability of this vulnerability.

4. Monitor XML input handling: Analyze runtime behavior to confirm that XML input is being processed correctly and check for any anomalous behaviors when unrecognized input is encountered.
   
```bash
   # Use the application logs to check for any errors related to XML processing
   tail -f /path/to/your/application/logs/application.log | grep "unmarshal"
```  
   This monitoring ensures that the application is safeguarding against malformed XML inputs and provides insights into potential exploitation attempts.

## 受影响版本(生成式)

- XStream: Versions 1.4.9 and earlier are vulnerable [[1]](#引用) .

## 不受影响版本(生成式)

- XStream: Versions 1.4.10 and later [[1]](#引用)   
- XStream: Versions >= 1.4.11 (exclusive) [[4]](#引用)   

Other packages mentioned:  
- Debian Linux: Versions 8.0 and 9.0 [[3]](#引用) 

## 规避方案(生成式)

1. DenyTypes Workaround Implementation: Modify your application code to include the 'denyTypes' setting, ensuring that the XStream library does not allow the deserialization of the primitive type 'void'. This can be accomplished by configuring a blacklist of disallowed types in your XStream setup [[7]](#引用) .  

   Implementation Steps:  
   - Update your code to create an instance of 'XStream' and configure it as follows:  
   
```java  
   import com.thoughtworks.xstream.XStream;  

   public class SecureExample {  
       public static void main(String[]  args) {  
           XStream xstream = new XStream();  
           xstream.addDefaultImplementation(Void.class, void.class); // Prevents deserialization of 'void'  
           // Define other safe types as necessary to limit risks  
           // Example of configuring denyTypes  
           xstream.denyTypes(new Class[] {void.class});  
           // Safely handle your XML inputs here  
       }  
   }  
```  
   This code modification prevents the unsafe unmarshalling of '<void/>' by explicitly denying the associated type, effectively mitigating the risk of service denial due to this vulnerability [[7]](#引用) .  

2. Upgrade to Secure Version: Ensure that your application is using an updated version of the XStream library by upgrading to version 1.4.10 or later, where the vulnerability has been addressed [[4]](#引用) .  
   
   Implementation Steps:  
   - Modify your build configuration to pull in the new version of XStream. If using Maven, update your 'pom.xml' file:  
   
```xml  
   <dependency>  
       <groupId>com.thoughtworks.xstream</groupId>  
       <artifactId>xstream</artifactId>  
       <version>1.4.10</version>  
   </dependency>  
```  
   - For Gradle, modify your 'build.gradle' file:  
   
```groovy  
   dependencies {  
       implementation 'com.thoughtworks.xstream:xstream:1.4.10'  
   }  
```  
   After updating, verify the application’s functionality through comprehensive testing [[4]](#引用) . This method directly addresses the known vulnerability and removes risks associated with outdated versions.

## 受影响版本(总结式)

- Component: XStream'    - Affected Versions: 1.4.9 and earlier (inclusive) [[7]](#引用) '

## 不受影响版本(总结式)

- Component: XStream  
    - Unaffected Versions: Versions >= 1.4.10 (exclusive) [[7]](#引用) , Versions >= 1.4.11 (exclusive) [[4]](#引用) , 1.4.10 and later [[1]](#引用) , 1.4.9 and later [[3]](#引用)   


## 排查步骤(总结式)

- Check Installation of the Program: Verify that XStream is installed in your software environment [[3]](#引用) .

- Check Program Version: Confirm that the version of XStream is 1.4.9 or earlier, as these are known to contain the vulnerability [[3]](#引用) .

- Review DenyTypes Configuration: Ensure that the denyTypes workaround is implemented in your application to mitigate the vulnerability [[1]](#引用) .

- Inspect Application Input Handling: Analyze how your application processes input, especially during XStream unmarshalling, to identify potential vulnerabilities [[3]](#引用) .

## 规避方案(总结式)

- Upgrade to XStream version 1.4.10 or later, which includes fixes for CVE-2017-7957 [[7]](#引用) [[4]](#引用) .
- Apply the denyTypes workaround to prevent deserialization of the primitive type 'void' [[7]](#引用) [[1]](#引用) [[3]](#引用) .
- Conduct thorough testing after upgrades to ensure the application functions as expected [[7]](#引用) .
- Inform users about the denial of service risks and advise caution when processing untrusted XML inputs [[7]](#引用) .
- Implement proper input validation to handle various data types and mitigate unintended behaviors [[3]](#引用) .

## 利用分析

CVE-2017-7957 is a denial of service vulnerability present in XStream versions up to 1.4.9 due to its mishandling of XML unmarshalling for the primitive type 'void' when the `denyTypes` configuration is not applied [[7]](#引用) . Attackers can exploit this vulnerability by following these detailed steps: 1. Create Malicious XML: Develop a carefully crafted XML payload, specifically using the element '<void/>', which is designed to initiate the instantiation of the 'void' type during unmarshalling [[7]](#引用) [[1]](#引用) . 2. Deliver the Payload: Send the malicious XML to a vulnerable application that utilizes XStream for XML parsing. This can typically be achieved through HTTP requests or any other mechanism that allows XML submission [[7]](#引用) . 3. Unmarshal the Payload: The vulnerable application will process the incoming XML. If it does not have the necessary `denyTypes` configuration, the unmarshalling process will proceed incorrectly, trying to create an instance of 'void' [[7]](#引用) . 4. Trigger System Failure: Once the application attempts to unmarshal the payload, it will crash or become unresponsive due to the mishandling of the 'void' type, resulting in a denial of service condition for legitimate users [[7]](#引用) [[1]](#引用) . Preventive measures are critical, including updating XStream to versions past 1.4.9 [[7]](#引用) [[3]](#引用)  and implementing appropriate security configurations such as the `denyTypes` setting to block unsupported types. Without these controls, the vulnerability remains exploitable, posing a risk to the application's availability.

## 根因分析

The root cause of the vulnerability CVE-2017-7957 lies in the improper input validation during the unmarshalling process within the XStream library. Specifically, the vulnerable code allows an unauthenticated attacker to trigger the 'xstream.fromXML("<void/>")' call, leading to a potential denial of service (DoS) by exploiting the mishandling of the primitive type 'void' [[7]](#引用) .

 Part 1: Lack of Input Validation for Primitive Types
The code snippet below is from the 'SunLimitedUnsafeReflectionProvider' class:


```java
@Override
public Object newInstance(final Class<?> type) {
    if (exception != null) {
        final ObjectAccessException ex = new ObjectAccessException("Cannot construct type", exception);
        ex.add("construction-type", type.getName());
        throw ex;
    }
    ErrorWritingException ex = null;
    try {
        return unsafe.allocateInstance(type);
    } catch (final SecurityException e) {
        ex = new ObjectAccessException("Cannot construct type", e);
    } catch (final InstantiationException e) {
        ex = new ConversionException("Cannot construct type", e);
    } catch (final IllegalArgumentException e) {
        ex = new ObjectAccessException("Cannot construct type", e);
    }
    ex.add("construction-type", type.getName());
    throw ex;
}
```

This code attempts to create a new instance of the specified class type using 'unsafe.allocateInstance(type)'. However, it does not validate whether the requested type is a primitive type or not. Since Java's 'void' type technically does not have any instances, the lack of validation allows for an unsafe operation to occur when attacker-defined input is processed. This can lead to a situation where the system attempts to instantiate 'void', resulting in unexpected behavior and potential resource exhaustion [[3]](#引用) .

 Part 2: Ignoring the Special Case for Void Type
The following code section from the 'PrimitiveTypePermission' class illustrates the oversight in permissions handling:


```java
@Override
public boolean allows(Class<?> type) {
    return type != null && type.isPrimitive() || Primitives.isBoxed(type);
}
```

This method checks if a type is a primitive or a boxed type but does not explicitly exclude 'void' or 'Void' from its check. Because of this, a class of type 'void' is permitted through the unmarshalling process, which blatantly violates the core principle of object-oriented design by attempting to instantiate a type that inherently cannot be instantiated. If this logic is exploited, it could allow harmful requests to bypass intended safeguards, leading to a denial of service [[5]](#引用) .

 Part 3: Unholistic Handling of XML Parsing
The issue also exists in how XML is parsed and transformed into objects. In the test cases within 'SecurityVulnerabilityTest.java', the following snippet is crucial:


```java
public void testDeniedInstanceOfVoid() {
    try {
        xstream.fromXML("<void/>);
        fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
    } catch (final ForbiddenClassException e) {
        // OK
    }
}
```

Here, the code aims to prevent the instantiation of 'void' via tests but does not prevent its potential processing beforehand. This indicates that the actual vulnerability resides in the unhandled case where the parser allows a '<void/>' input without robust prior checks against the type. If a malicious actor sends such a request, it could lead to DoS, as the system may hang or exhaust its resources while attempting to resolve this nonsensical request [[4]](#引用) .

 Summary of the Root Cause
Multiple rooted parts contribute to the overall vulnerability: the lack of input validation on primitive types during instance creation [[1]](#引用) , the failure to explicitly handle the 'void' case in type permission checks, and the inadequate parsing logic [[8]](#引用) . Together, these issues enable an attacker to create requests that destabilize or crash the application, exemplifying the importance of stringent validation and comprehensive type handling in serialization libraries.

## 修复解释

In the patch addressing CVE-2017-7957, which is intended to prevent deserialization of the primitive type 'void', significant modifications were made to the `SunLimitedUnsafeReflectionProvider.java` file located at `xstream/src/java/com/thoughtworks/xstream/converters/reflection/`. The following changes were made:


```java
-        try {
-            return unsafe.allocateInstance(type);
-        } catch (final SecurityException e) {
-            ex = new ObjectAccessException("Cannot construct type", e);
-        } catch (final InstantiationException e) {
-            ex = new ConversionException("Cannot construct type", e);
-        } catch (final IllegalArgumentException e) {
-            ex = new ObjectAccessException("Cannot construct type", e);
+        if (type == void.class || type == Void.class) {
+            ex = new ConversionException("Type void cannot have an instance");
+        } else {
+            try {
+                return unsafe.allocateInstance(type);
+            } catch (final SecurityException e) {
+                ex = new ObjectAccessException("Cannot construct type", e);
+            } catch (final InstantiationException e) {
+                ex = new ConversionException("Cannot construct type", e);
+            } catch (final IllegalArgumentException e) {
+                ex = new ObjectAccessException("Cannot construct type", e);
+            }
```
This modification introduces a check that specifically prevents the allocation of an instance for the `void` type. By evaluating if `type` is `void.class` or `Void.class`, it will throw a `ConversionException` with the message "Type void cannot have an instance". This addition ensures that dangerous XML inputs that attempt to create instances of 'void' are properly handled, effectively mitigating the previously exploitable vulnerability.

Additionally, updates were made to the `PrimitiveTypePermission.java` file, which is located at `xstream/src/java/com/thoughtworks/xstream/security/`:


```java
- * Permission for any primitive type and its boxed counterpart (incl. void).
+ * Permission for any primitive type and its boxed counterpart (excl. void).
```
This comment modification clarifies that permission checks now exclude `void`, aligning with the new security measures implemented in the code.

Lastly, in `SecurityVulnerabilityTest.java`, found at `xstream/src/test/com/thoughtworks/acceptance/`, tests were added to confirm the proper handling of the void type during XML deserialization:


```java
+    public void testDeniedInstanceOfVoid() {
+        try {
+            xstream.fromXML("<void/>");
+            fail("Thrown " + ForbiddenClassException.class.getName() + " expected");
+        } catch (final ForbiddenClassException e) {
+            // OK
+        }
+
+    public void testAllowedInstanceOfVoid() {
+        xstream.allowTypes(void.class, Void.class);
+        try {
+            xstream.fromXML("<void/>");
+            fail("Thrown " + ConversionException.class.getName() + " expected");
+        } catch (final ConversionException e) {
+            assertEquals("void", e.get("construction-type"));
+        }
```
These tests validate that the system correctly prevents the creation of instances of `void`, effectively ensuring that the library no longer crashes when it encounters `<void/>` in XML input.

This patch was committed with the ID `b3570be2f39234e61f99f9a20640756ea71b1b40`, ensuring that such inputs cannot lead to a denial-of-service condition.The patch for the code is at: https://api.github.com/repos/x-stream/xstream/commits/b3570be2f39234e61f99f9a20640756ea71b1b40

## 引用

- [1]  https://www.cvedetails.com/cve/CVE-2017-7957
- [2]  http://markmail.org/message/swots657f6vah5sm?q=struts+list:org%2Eapache%2Estruts%2Edev
- [3]  https://app.soos.io/research/vulnerabilities/CVE-2017-7957
- [4]  https://paper.seebug.org/1417/
- [5]  http://markmail.org/message/swots657f6vah5sm?q=struts+list:org%2Eapache%2Estruts%2Edev:
- [6]  https://nvd.nist.gov/vuln/detail/CVE-2017-7957
- [7]  https://cve.circl.lu/cve/CVE-2017-7957
- [8]  https://vulners.com/cve/CVE-2017-7957

