## 漏洞描述

The PyCryptodome library in Python versions prior to 3.6.6 is vulnerable to an integer overflow in the data_len variable within AESNI.c [[4]](#引用) , which affects the AESNI_encrypt and AESNI_decrypt functions [[5]](#引用) . This vulnerability allows an attacker to exploit the mishandling of messages shorter than 16 bytes [[4]](#引用) , potentially leading to unexpected behavior during cryptographic operations via crafted input lengths [[2]](#引用) . The flaw can result in partial availability impact or integrity concerns regarding the encryption process [[1]](#引用) .

## 详细描述

CVE-2018-15560 is an integer overflow vulnerability found in versions of PyCryptodome prior to 3.6.6 [[4]](#引用) [[5]](#引用) [[3]](#引用) . This issue arises in the AESNI.c implementation, specifically within the AESNI_encrypt and AESNI_decrypt functions, resulting in the improper handling of messages shorter than 16 bytes [[4]](#引用) [[5]](#引用) . The core of the vulnerability lies in the data_len variable, where erroneous arithmetic calculations can lead to an overflow, causing the integer value to wraparound into a smaller or negative representation [[5]](#引用) [[2]](#引用) [[3]](#引用) . When exploiting this vulnerability, an attacker could potentially manipulate input to produce unexpected results during cryptographic operations, thereby jeopardizing the security and integrity of encrypted data [[2]](#引用) [[3]](#引用) [[1]](#引用) . The severity of this vulnerability has been rated with a CVSS base score of 7.5, classifying it as high risk, indicating substantial potential impact on system availability while presenting low risks to confidentiality and integrity [[3]](#引用) [[2]](#引用) . Exploitation of the vulnerability can disrupt normal operations of the encryption and decryption processes, posing a significant risk to applications relying on this cryptographic library [[3]](#引用) [[2]](#引用) .

## 排查步骤(生成式)

- Check for PyCryptodome: Verify if your application uses the PyCryptodome library, which is the vulnerable package.
  
```python
  import pkg_resources
  pkg_resources.require("pycryptodome")
```
  This check helps confirm whether the application relies on a vulnerable library known to be affected by the CVE.

- Check for affected versions: If PyCryptodome is in use, check the version of PyCryptodome. If the version is less than 3.6.6 (exclusive), the installation is vulnerable.
  
```python
  import Crypto
  print(Crypto.__version__)
```
  Knowing the specific version allows you to ascertain if your application is within the vulnerable range, making it crucial for patching decisions.

- Check for usage in cryptographic functions: Determine if the `AESNI_encrypt` or `AESNI_decrypt` functions are called in your application. This can often be done through static analysis or by reviewing the codebase for references.
  
```bash
  grep -R "AESNI_encrypt" /path/to/your/application
  grep -R "AESNI_decrypt" /path/to/your/application
```
  Verifying the use of these functions indicates whether your application may be susceptible to this specific exploit during cryptographic operations.

- Review input handling: Ensure the application does not accept input lengths shorter than 16 bytes without proper validation, as this can trigger the overflow vulnerability.
  
```python
  # An example check; implement proper input validation in your application code
  if data_len < 16:
      raise ValueError("Input length must be at least 16 bytes.")
```
  Ensuring proper length validation is a proactive measure to prevent exploitation, addressing the core of the vulnerability's mechanics.

## 受影响版本(生成式)

- PyCryptodome: All versions before 3.6.6 (exclusive) are vulnerable [[4]](#引用) [[5]](#引用) [[2]](#引用) [[3]](#引用) .

## 不受影响版本(生成式)

- Component: PyCryptodome
  - Unaffected Versions: 3.6.6 and later [[4]](#引用) 

- Unaffected packages: PyCryptodome [[5]](#引用) 

## 规避方案(生成式)

1. Upgrade PyCryptodome:  Implement the following command to upgrade the PyCryptodome library to a secure version (3.6.6 or later): 
```bash pip install --upgrade pycryptodome ``` This upgrade directly mitigates the vulnerability by addressing the integer overflow issue in the 'AESNI.c' file, ensuring that cryptographic operations are handled correctly and securely [[5]](#引用) . By using a version that has patched the flaw, the application is protected against potential exploits that could compromise data integrity or availability.  2. Input Validation for Message Length:  If direct code modification of the PyCryptodome library is not possible, enforce input validation in your application wherever PyCryptodome encryption functions are called. Add checks to ensure that any message being processed is at least 16 bytes in length: 
```python def safe_encrypt(data): if len(data) < 16: raise ValueError('Input data must be at least 16 bytes long.') ' Proceed with AES encryption using PyCryptodome from Crypto.Cipher import AES cipher = AES.new(key, AES.MODE_ECB) return cipher.encrypt(data) ``` This mitigation prevents the usage of messages that could trigger the vulnerability, by ensuring that all data processed is of an acceptable size [[4]](#引用) . This adds a layer of security on top of using a patched version of the library and further reduces the risk associated with handling shorter inputs.

## 受影响版本(总结式)

- Component: PyCryptodome
  - Affected Versions: Before 3.6.6 (exclusive) [[4]](#引用) 

## 不受影响版本(总结式)

- Component: PyCryptodome
    - Unaffected Versions: 3.6.6 and above [[4]](#引用) 


## 排查步骤(总结式)

- Check the installation of PyCryptodome to ensure it is present on the system [[4]](#引用) .
- Verify that the version of PyCryptodome is 3.6.6 or higher, as versions below this are vulnerable [[5]](#引用) .
- Assess the potential impact of the vulnerability, specifically the integer overflow in the `data_len` variable in AESNI.c affecting message handling [[5]](#引用) [[3]](#引用) .
- Review application dependencies to confirm there are no components relying on affected versions of PyCryptodome [[4]](#引用) [[3]](#引用) .

## 规避方案(总结式)

- Upgrade to PyCryptodome version 3.6.6 or later to mitigate the vulnerability [[4]](#引用) .
- Ensure that the application does not process messages shorter than 16 bytes if using affected versions [[4]](#引用) .

## 利用分析

CVE-2018-15560 pertains to an integer overflow vulnerability in the 'data_len' variable found in the 'AESNI.c' file of PyCryptodome prior to version 3.6.6, specifically affecting the 'AESNI_encrypt' and 'AESNI_decrypt' functions [[4]](#引用) . This vulnerability can be exploited by an attacker as follows: 1. The attacker initiates the exploit by sending a specially crafted message that is intentionally shorter than 16 bytes to the vulnerable application utilizing PyCryptodome [[4]](#引用) . 2. The integer overflow occurs as the system processes this short message, leading to improper handling within the cryptographic functions [[5]](#引用) . 3. By manipulating the resultant behavior from this overflow, the attacker may achieve unauthorized access to sensitive data or perform unauthorized modifications, effectively compromising the integrity and confidentiality of the system [[4]](#引用) . 4. The vulnerability can be exploited over a network, allowing remote exploitation without any required user interaction or authentication, indicating a potentially high-impact threat, including denial-of-service scenarios [[3]](#引用) . Overall, the key to the attack involves carefully crafting inputs to exploit the overflow condition, emphasizing the need for stringent input validation and version upgrades to mitigate this risk [[3]](#引用) .

## 根因分析

The vulnerability CVE-2018-15560 in the PyCryptodome library primarily stems from how the AES encryption and decryption functions handle data lengths less than 16 bytes [[4]](#引用) . Below are the identified parts of the root cause, each contributing to the vulnerability.

 Part 1: Lack of Input Length Validation
The lack of sufficient validation on the `data_len` variable creates an integer overflow issue for input lengths less than 16 bytes [[5]](#引用) .

Relevant Code Snippet:

```c
static int AESNI_encrypt(const BlockBase *bb, const uint8_t *in, uint8_t *out, size_t data_len) {
    ...
    / There are 7 blocks or fewer left /
    for (;data_len>0; data_len-=16, in+=16, out+=16) {
        ...
    }
}
```

Explanation:
In the `AESNI_encrypt` function, there is a for-loop designed to process data in blocks of 16 bytes [[1]](#引用) . Since there is no preliminary check to ensure that `data_len` is at least 16 bytes before entering the loop, if `data_len` is set to a value less than 16, the condition `data_len > 0` will still be true. This allows the loop to execute, leading to undefined behavior as it attempts to process non-existent data blocks. An attacker could leverage this circumstance to cause segmentation faults or unexpected behaviors during cryptographic operations.

 Part 2: Incorrect Handling of Remaining Data
The behavior of the algorithm when handling remaining data that does not fit into a full block can also be problematic, leading to integrity concerns [[3]](#引用) .

Relevant Code Snippet:

```c
for (;data_len>0; data_len-=16, in+=16, out+=16) {
    __m128i pt, data;
    unsigned i;
    
    pt = _mm_loadu_si128((__m128i*)in);
    ...
}
```

Explanation:
In the above code, after the main data processing loop, there is an attempt to process any remaining data that isn't part of a full block (i.e., less than 16 bytes) [[2]](#引用) . If `data_len` is less than 16 but greater than 0, this could lead to reading beyond the bounds of the input buffer `in`, leading to a risk of unauthorized memory access and potential data leakage. The integrity of the cryptographic process is compromised when the encryption logic is applied to partial blocks without proper padding or error handling.

 Part 3: Unchecked Memory Operations
The functions lack proper error handling and constraints related to memory operations, providing another vector for exploitation [[4]](#引用) .

Relevant Code Snippet:

```c
if ((bb == NULL) || (in == NULL) || (out == NULL))
    return ERR_NULL;
```

Explanation:
The checks for null pointers only protect against uninitialized pointers but do not validate the ranges or sizes of buffers. If an attacker sends a manipulated `data_len`, combined with the previous unchecked conditions, it can lead to integer overflows or memory corruption [[4]](#引用) . The failure to comprehensively validate input size and pointer integrity before memory operations exacerbates the risk of buffer overflows.

 Summary
In summary, the identified parts of the root cause of the vulnerability involve a lack of proper input validation for the `data_len` variable, incorrect handling of remaining data, and inadequate checks around memory operations [[1]](#引用) . Together, these issues allow for potential exploitation by processing improperly sized data, leading to cryptographic failures and integrity concerns in the encryption process. The patch addresses these by enforcing checks on the input sizes before any cryptographic processing occurs.

## 修复解释

In the patch identified by commit `d1739c62b9b845f8a5b342de08d6bf6e2722d247`, modifications were made to the `src/AESNI.c` file in the `AESNI_encrypt` and `AESNI_decrypt` functions to address the integer overflow vulnerability related to message lengths shorter than 16 bytes.

### Changes in `src/AESNI.c`

Original Code:

```c
for (;data_len>0; data_len-=16, in+=16, out+=16) {
```

Patched Code:

```c
for (;data_len>=BLOCK_SIZE; data_len-=BLOCK_SIZE, in+=BLOCK_SIZE, out+=BLOCK_SIZE) {
```
The change from `data_len>0` to `data_len>=BLOCK_SIZE` ensures that the function only processes data that is at least the size of one AES block (16 bytes). This effectively prevents the encryption and decryption routines from attempting to process insufficiently sized input data, which could cause improper memory handling and potential buffer overflows due to previously allowed negative or small values of `data_len`. Thus, this fix directly mitigates the integer overflow vulnerability described in CVE-2018-15560.

These changes ensure that the `AESNI_encrypt` and `AESNI_decrypt` functions will no longer process if there are fewer than 16 bytes of data, securing the handling of input data and ensuring compliant cryptographic operations.The patch for the code is at: https://api.github.com/repos/Legrandin/pycryptodome/commits/d1739c62b9b845f8a5b342de08d6bf6e2722d247

## 引用

- [1]  https://nvd.nist.gov/vuln/detail/CVE-2018-15560
- [2]  https://vulners.com/cve/CVE-2018-15560
- [3]  https://app.soos.io/research/vulnerabilities/CVE-2018-15560
- [4]  https://cve.circl.lu/cve/CVE-2018-15560
- [5]  https://www.cvedetails.com/cve/CVE-2018-15560

